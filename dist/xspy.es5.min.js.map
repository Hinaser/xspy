{"version":3,"sources":["webpack://xspy/webpack/universalModuleDefinition","webpack://xspy/webpack/bootstrap","webpack://xspy/./src/Proxy.ts","webpack://xspy/./src/index.lib.ts","webpack://xspy/./src/modules/XMLHttpRequest.ts","webpack://xspy/./src/modules/Response.ts","webpack://xspy/./src/modules/fetch.ts","webpack://xspy/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","version","enable","XMLHttpRequest","Proxy","_customXHR","fetch","_customFetch","disable","OriginalXHR","OriginalFetch","isEnabled","setXMLHttpRequest","setFetch","getRequestListeners","_reqListeners","slice","getResponseListeners","_resListeners","onRequest","listener","listeners","this","indexOf","splice","push","offRequest","_removeEventListener","onResponse","offResponse","clearAll","clearRequestHandler","clearResponseHandler","type","length","userAgent","navigator","IEVersion","parseInt","exec","toLowerCase","isNaN","isIE","op","createEvent","Event","ev","document","initEvent","e","makeProgressEvent","loaded","lengthComputable","total","target","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","_xhr","_listeners","_readyState","_isAborted","_hasError","_transitioning","_request","XHRProxy","_createRequest","_response","_createResponse","_responseText","_responseXML","readyState","status","statusText","timeout","upload","response","responseType","responseURL","withCredentials","onreadystatechange","onabort","onerror","onloadstart","onload","onloadend","ontimeout","onprogress","_init","Error","_onError","_createRequestCallback","addEventListener","realReadyState","async","_loadHeaderFromXHRToVirtualResponse","_loadBodyFromXHRToVirtualResponse","_runUntil","options","removeEventListener","index","dispatchEvent","event","TypeError","onHandlerPropName","handler","overrideMimeType","mime","open","method","url","username","password","arguments","headers","send","body","DOMException","_setupVirtualRequestForSending","_syncEventListenersToXHR","isDispatchXHRSendCalled","listenerPointer","executeNextListener","headerMap","headerNames","keys","headerName","headerValue","setRequestHeader","dispatchXHRSend","userCallback","console","warn","lowerName","getResponseHeader","lowerHeaderName","getAllResponseHeaders","join","toHeaderString","abort","xhr","ajaxType","finalUrl","addEventListeners","localListeners","onCalled","cb","moveToHeaderReceived","moveToLoading","_createResponseCallback","responseHeaders","trim","split","map","parts","shift","toHeaderMap","responseText","responseXML","_syncHeaderFromVirtualResponse","_syncBodyFromVirtualResponse","_triggerStateAction","readyStateChangeEvent","emitLoadEvent","setTimeout","state","init","Response","_body","Headers","undefined","ok","redirected","trailer","bodyUsed","error","redirect","clone","ResponseProxy","arrayBuffer","blob","formData","json","text","input","_input","dispatch","_onResponse","FetchProxy","Promise","resolve","reject","originalResponse","isDispatchFetchCalled","requestListeners","then","isReturnResponseCalled","responseListeners","res","returnResponse","req","entries","Array","from","pair","cache","credentials","integrity","keepalive","referrer","referrerPolicy","signal"],"mappings":"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","file":"xspy.es5.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"xspy\"] = factory();\n\telse\n\t\troot[\"xspy\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {EventType, RequestHandler, ResponseHandler, WindowEx} from \"./index.type\";\n\ndeclare let window: WindowEx;\n\nexport class Proxy {\n  private static _reqListeners: Array<RequestHandler<\"xhr\"|\"fetch\">> = [];\n  private static _resListeners: Array<ResponseHandler<\"xhr\"|\"fetch\">> = [];\n  private static _customXHR = window.XMLHttpRequest;\n  private static _customFetch = window.fetch;\n  public static readonly OriginalXHR = window.XMLHttpRequest;\n  /* Only IE does not implement `window.fetch`. Exclude from coverage counting. */\n  /* istanbul ignore next */\n  public static readonly OriginalFetch = (window.fetch || function fetch(){ return; }).bind(window);\n  \n  public static enable() {\n    window.XMLHttpRequest = Proxy._customXHR;\n    /* istanbul ignore else */\n    if(window.fetch){\n      window.fetch = Proxy._customFetch;\n    }\n  }\n  \n  public static disable() {\n    window.XMLHttpRequest = Proxy.OriginalXHR;\n    /* istanbul ignore else */\n    if(window.fetch && Proxy.OriginalFetch){\n      window.fetch = Proxy.OriginalFetch;\n    }\n  }\n  \n  public static isEnabled(){\n    return window.XMLHttpRequest === Proxy._customXHR;\n  }\n  \n  public static setXMLHttpRequest(m: typeof window[\"XMLHttpRequest\"]){\n    Proxy._customXHR = m;\n  }\n  \n  public static setFetch(m: typeof window[\"fetch\"]){\n    Proxy._customFetch = m;\n  }\n  \n  public static getRequestListeners() {\n    const listeners = Proxy._reqListeners;\n    return listeners.slice();\n  }\n  \n  public static getResponseListeners() {\n    const listeners = Proxy._resListeners;\n    return listeners.slice();\n  }\n  \n  public static onRequest(listener: RequestHandler<\"xhr\"|\"fetch\">, n?: number) {\n    const listeners = this._reqListeners;\n    if (listeners.indexOf(listener) > -1) {\n      return;\n    }\n  \n    if (typeof n === \"number\") {\n      listeners.splice(n, 0, listener);\n    } else {\n      listeners.push(listener);\n    }\n  }\n  \n  public static offRequest(listener: RequestHandler<\"xhr\"|\"fetch\">) {\n    this._removeEventListener(\"request\", listener);\n  }\n  \n  public static onResponse(listener: ResponseHandler<\"xhr\"|\"fetch\">, n?: number) {\n    const listeners = this._resListeners;\n    if (listeners.indexOf(listener) > -1) {\n      return;\n    }\n  \n    if (typeof n === \"number\") {\n      listeners.splice(n, 0, listener);\n    } else {\n      listeners.push(listener);\n    }\n  }\n  \n  public static offResponse(listener: ResponseHandler<\"xhr\"|\"fetch\">) {\n    this._removeEventListener(\"response\", listener);\n  }\n  \n  public static clearAll() {\n    Proxy.clearRequestHandler();\n    Proxy.clearResponseHandler();\n  }\n  \n  public static clearRequestHandler() {\n    this._reqListeners = [];\n  }\n  \n  public static clearResponseHandler() {\n    this._resListeners = [];\n  }\n  \n  private static _removeEventListener(type: EventType, listener: RequestHandler<\"xhr\"|\"fetch\"> | ResponseHandler<\"xhr\"|\"fetch\">) {\n    const listeners = type === \"request\" ? this._reqListeners : this._resListeners;\n    \n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener) {\n        listeners.splice(i, 1);\n        return;\n      }\n    }\n  }\n}\n","const userAgent = typeof navigator !== \"undefined\" && navigator.userAgent ? navigator.userAgent : \"\";\n\n// If browser is not IE, IEVersion will be NaN\nexport const IEVersion = (() => {\n  let version = parseInt((/msie (\\d+)/.exec(userAgent.toLowerCase()) || [])[1], 10);\n  \n  /* istanbul ignore else */\n  if(isNaN(version)) {\n    version = parseInt((/trident\\/.*; rv:(\\d+)/.exec(userAgent.toLowerCase()) || [])[1], 10);\n    /* istanbul ignore else */\n    if(isNaN(version)){\n      return false;\n    }\n    /* istanbul ignore next */\n    return version;\n  }\n  \n  /* istanbul ignore next */\n  return version;\n})();\n\n/* istanbul ignore next */\nexport function isIE(op?: \"<\"|\"<=\"|\">\"|\">=\"|\"=\", version?: number){\n  if(IEVersion === false) return false;\n  else if(!version) return true;\n  else if(op === \"<\") return IEVersion < version;\n  else if(op === \"<=\") return IEVersion <= version;\n  else if(op === \">\") return IEVersion > version;\n  else if(op === \">=\") return IEVersion >= version;\n  else if(op === \"=\") return IEVersion === version;\n  return IEVersion === version;\n}\n\nexport const createEvent = (type: string): Event => {\n  try{\n    /* istanbul ignore else */\n    if(!isIE() && typeof Event !== \"undefined\"){\n      return new Event(type);\n    }\n    \n    // When browser is IE, `new Event()` will fail.\n    /* istanbul ignore next */\n    const ev = window.document.createEvent(\"Event\");\n    /* istanbul ignore next */\n    ev.initEvent(type);\n    /* istanbul ignore next */\n    return ev;\n  }\n  catch(e){\n    /* istanbul ignore next */\n    return {\n      type,\n    } as Event;\n  }\n};\n\nexport const toHeaderMap = (responseHeaders: string) => {\n  const headers = responseHeaders.trim().split(/[\\r\\n]+/)\n  \n  const map: {[name: string]: string} = {};\n  for(let i=0;i<headers.length;i++){\n    const line = headers[i];\n    const parts = line.split(\": \");\n    const name = parts.shift();\n    if(name){\n      const lowerName = name.toLowerCase();\n      map[lowerName] = parts.join(\": \");\n    }\n  }\n  \n  return map;\n}\n\nexport const toHeaderString = (headerMap: {[name: string]: string}) => {\n  const headers: string[] = [];\n  const keys = Object.keys(headerMap);\n  \n  for(let i=0;i<keys.length;i++){\n    const key = keys[i];\n    const name = key.toLowerCase();\n    const value = headerMap[key];\n    \n    headers.push(name + \": \" + value);\n  }\n  \n  return headers.join(\"\\r\\n\") + \"\\r\\n\";\n};\n\nexport const makeProgressEvent = (type: string, loaded: number, lengthComputable: boolean = false, total: number = 0) => {\n  const ev: ProgressEvent<XMLHttpRequestEventTarget> = {\n    ...createEvent(type),\n    type,\n    target: null,\n    loaded,\n    lengthComputable,\n    total,\n  };\n  \n  return ev;\n}\n","import {RequestCallback, ResponseCallback, XhrRequest, XhrResponse} from \"../index.type\";\nimport {createEvent, makeProgressEvent, toHeaderMap, toHeaderString, isIE} from \"../index.lib\";\nimport {Proxy} from \"../Proxy\";\n\nexport class XHRProxy implements XMLHttpRequest {\n  static readonly UNSENT: number = 0;\n  static readonly OPENED: number = 1;\n  static readonly HEADERS_RECEIVED: number = 2;\n  static readonly LOADING: number = 3;\n  static readonly DONE: number = 4;\n  \n  public readonly UNSENT: number = 0;\n  public readonly OPENED: number = 1;\n  public readonly HEADERS_RECEIVED: number = 2;\n  public readonly LOADING: number = 3;\n  public readonly DONE: number = 4;\n  \n  private _xhr = new Proxy.OriginalXHR();\n  private _listeners: {[type: string]: Array<(this: XMLHttpRequest, ev: Event|ProgressEvent<XMLHttpRequestEventTarget>) => unknown>} = {};\n  private _readyState: number = 0;\n  private _isAborted: boolean = false;\n  private _hasError: boolean|null = null;\n  private _transitioning: boolean|null = null;\n  private _request: XhrRequest = XHRProxy._createRequest(this._xhr);\n  private _response: XhrResponse = XHRProxy._createResponse();\n  private _responseText: string = \"\";\n  private _responseXML: Document | null = null;\n  \n  public readyState = 0;\n  public status = 0;\n  public statusText = \"\";\n  public timeout: number = 0;\n  public readonly upload = this._xhr.upload;\n  \n  public response: BodyInit|Document|null|undefined = \"\";\n  public responseType: XMLHttpRequestResponseType = \"\";\n  public responseURL: string = \"\";\n  public get responseText(): string {\n    if(this.responseType === \"text\" || this.responseType === \"\"){\n      return this._responseText;\n    }\n    /* istanbul ignore next */\n    else if(isIE(\">=\", 10)){\n      return this._responseText;\n    }\n    const e = new Error(\"responseText is only available if responseType is '' or 'text'.\");\n    e.name = \"InvalidStateError\";\n    throw e;\n  }\n  public get responseXML(): Document | null {\n    if(this.responseType === \"document\" || this.responseType === \"\"){\n      return this._responseXML;\n    }\n    /* istanbul ignore next */\n    else if(isIE(\">=\", 10)){\n      return this._responseXML;\n    }\n    const e = new Error(\"responseXML is only available if responseType is '' or 'document'.\");\n    e.name = \"InvalidStateError\";\n    throw e;\n  }\n  public withCredentials: boolean = false;\n  \n  public onreadystatechange: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onabort: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onerror: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onloadstart: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onload: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onloadend: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public ontimeout: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onprogress: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  \n  constructor() {\n    this._init();\n  }\n  \n  private _init(){\n    this._onError = this._onError.bind(this);\n    this._createRequestCallback = this._createRequestCallback.bind(this);\n  \n    const addEventListener = <K extends keyof XMLHttpRequestEventMap>(type: K) => {\n      this.addEventListener(type, this._onError);\n    }\n    addEventListener(\"error\");\n    addEventListener(\"timeout\");\n    addEventListener(\"abort\");\n    \n    this._xhr.onreadystatechange = () => {\n      // According to https://xhr.spec.whatwg.org/#the-abort()-method\n      // onreadystatechange should not be called,\n      // but some major browsers seems to call it actually.\n      /*\n      if(this._isAborted){\n        return;\n      }\n      */\n  \n      const realReadyState = this._xhr.readyState;\n      \n      if(realReadyState === this.HEADERS_RECEIVED){\n        /* istanbul ignore if */\n        if(isIE(\"<=\", 9) && /* istanbul ignore next */ this._request.async === false){\n          // For synchronous request in IE <= 9, it throws Error when accessing xhr header if readyState is less than LOADING.\n          // this._loadHeaderFromXHRToVirtualResponse();\n        }\n        else{\n          this._loadHeaderFromXHRToVirtualResponse();\n        }\n      }\n      else if(realReadyState === this.LOADING){\n        this._loadHeaderFromXHRToVirtualResponse();\n      }\n      else if(realReadyState === this.DONE){\n        this._transitioning = false;\n        this._loadHeaderFromXHRToVirtualResponse();\n        this._loadBodyFromXHRToVirtualResponse();\n      }\n      \n      this._runUntil(realReadyState);\n    };\n  }\n  \n  public addEventListener<K extends keyof XMLHttpRequestEventMap>(\n    type: K,\n    listener: (this: XMLHttpRequest, ev: Event|ProgressEvent<XMLHttpRequestEventTarget>) => unknown,\n    options?: boolean | AddEventListenerOptions\n  ){\n    if(!this._listeners[type]){\n      this._listeners[type] = [];\n    }\n    \n    this._listeners[type].push(listener);\n  }\n  \n  public removeEventListener<K extends keyof XMLHttpRequestEventMap>(\n    type: K,\n    listener: (this: XMLHttpRequest, ev: Event|ProgressEvent<XMLHttpRequestEventTarget>) => any,\n    options?: boolean | EventListenerOptions\n  ){\n    if(!this._listeners[type]){\n      return;\n    }\n    \n    const index = this._listeners[type].indexOf(listener);\n    if(index < 0){\n      return;\n    }\n    \n    this._listeners[type].splice(index, 1);\n  }\n  \n  public dispatchEvent(event: Event|ProgressEvent<XMLHttpRequestEventTarget>){\n    if(typeof event !== \"object\"){\n      throw new TypeError(\"EventTarget.dispatchEvent: Argument 1 is not an object\");\n    }\n    \n    const onHandlerPropName = \"on\" + event.type;\n    if(onHandlerPropName === \"onabort\"\n      || onHandlerPropName === \"onerror\"\n      || onHandlerPropName === \"onload\"\n      || onHandlerPropName === \"onloadend\"\n      || onHandlerPropName === \"onloadstart\"\n      || onHandlerPropName === \"onprogress\"\n      || onHandlerPropName === \"ontimeout\"\n    ){\n      const handler = this[onHandlerPropName];\n      if(handler){\n        handler.call(this, event as ProgressEvent<XMLHttpRequestEventTarget>);\n      }\n    }\n    else if(onHandlerPropName === \"onreadystatechange\"){\n      const handler = this[onHandlerPropName];\n      if(handler){\n        handler.call(this, event as Event);\n      }\n    }\n    \n    const listeners = this._listeners[event.type];\n    if(!listeners){\n      return true;\n    }\n    \n    for(let i=0;i<listeners.length;i++){\n      const l = listeners[i];\n      l.call(this, event);\n    }\n    return true;\n  }\n  \n  public overrideMimeType(mime: string) {\n    return this._xhr.overrideMimeType.call(this._xhr, mime);\n  }\n  \n  public open(method: string, url: string, async?: boolean, username?: string|null, password?: string|null){\n    if(arguments.length < 2){\n      throw new TypeError(\"XMLHttpRequest.open: \" + arguments.length + \" is not a valid argument count for any overload\");\n    }\n    \n    this._readyState = 0;\n    this._hasError = false;\n    this._isAborted = false;\n    this._transitioning = false;\n    \n    this._request = {\n      ...XHRProxy._createRequest(this._xhr),\n      headers: {},\n      method,\n      url,\n      async: async !== false,\n      username,\n      password,\n    };\n    \n    this._response = {\n      ...XHRProxy._createResponse(),\n      headers: {},\n    };\n    \n    this._runUntil(this.OPENED);\n  }\n  \n  public send(body?: Document | BodyInit | null) {\n    if(this._readyState !== this.OPENED){\n      throw new DOMException(\"XMLHttpRequest state must be OPENED\");\n    }\n  \n    this._setupVirtualRequestForSending(body);\n    this._syncEventListenersToXHR();\n    \n    let isDispatchXHRSendCalled = false;\n  \n    const dispatchXHRSend = () => {\n      isDispatchXHRSendCalled = true;\n      \n      // When requestCallback is used, readystate is automatically move forward to 'DONE'\n      // and produce dummy response.\n      if(this._readyState === this.DONE){\n        return;\n      }\n    \n      this._transitioning = true;\n      \n      const async = this._request.async !== false;\n    \n      this._xhr.open(\n        this._request.method,\n        this._request.url,\n        async,\n        this._request.username,\n        this._request.password\n      );\n    \n      if(async){\n        this._xhr.responseType = this.responseType;\n        this._xhr.timeout = this.timeout;\n      }\n      this._xhr.withCredentials = this.withCredentials;\n    \n      this.dispatchEvent(makeProgressEvent(\"loadstart\", 0));\n    \n      const headerMap = this._request.headers;\n      const headerNames = headerMap ? Object.keys(headerMap) : [];\n      for(let i=0;i<headerNames.length;i++){\n        const headerName = headerNames[i];\n        const headerValue = headerMap[headerName];\n        this._xhr.setRequestHeader(headerName, headerValue);\n      }\n    \n      this._xhr.send(this._request.body);\n    };\n  \n    const listeners = Proxy.getRequestListeners();\n    let listenerPointer = 0;\n  \n    const executeNextListener = (): unknown => {\n      try{\n        if(listenerPointer >= listeners.length){\n          return dispatchXHRSend();\n        }\n      \n        const l = listeners[listenerPointer];\n      \n        // l: (request, callback) => unknown\n        if(l.length >= 2){\n          const userCallback = this._createRequestCallback(() => {\n            listenerPointer++;\n            executeNextListener();\n          });\n        \n          l.call(this, this._request, userCallback as RequestCallback<\"xhr\"|\"fetch\">);\n          return;\n        }\n      \n        // l: (request) => unknown\n        l.call(this, this._request);\n      \n        listenerPointer++;\n        executeNextListener();\n      }\n      catch(e){\n        console.warn(\"XMLHttpRequest: Exception in request handler\", e);\n      \n        if(!isDispatchXHRSendCalled){\n          listenerPointer++;\n          executeNextListener();\n        }\n      }\n    };\n  \n    executeNextListener();\n  }\n  \n  public setRequestHeader(name: string, value: string) {\n    if(this.readyState !== this.OPENED){\n      throw new DOMException(\"XMLHttpRequest state must be OPENED\");\n    }\n    \n    if(!this._request.headers){\n      this._request.headers = {};\n    }\n    \n    const lowerName = name.toLowerCase();\n    if(this._request.headers[lowerName]){\n      value = this._request.headers[lowerName] + \", \" + value;\n    }\n    \n    this._request.headers[lowerName] = value;\n  }\n  \n  public getResponseHeader(name: string): string | null {\n    const lowerHeaderName = name.toLowerCase();\n    if(this.readyState < this.HEADERS_RECEIVED || !(lowerHeaderName in this._response.headers)){\n      // IE <= 9 throws Error when readyState is UNSENT\n      /* istanbul ignore next */\n      if(isIE(\"<=\", 9)){\n        if(this.readyState < this.OPENED){\n          throw new Error();\n        }\n        return \"\";\n      }\n      return null;\n    }\n    return this._response.headers[lowerHeaderName];\n  }\n  \n  public getAllResponseHeaders(): string {\n    if(this.readyState < this.HEADERS_RECEIVED){\n      // According to MDN, getAllResponseHeaders returns null if headers are not yet received.\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders\n      // But lib.dom.d.ts asserts it always returns string.\n      // Don't know which is correct.\n      \n      // IE <= 9 throws Error when readyState is UNSENT\n      /* istanbul ignore next */\n      if(isIE(\"<=\", 9) && this.readyState < this.OPENED){\n        throw new Error();\n      }\n      return \"\";\n    }\n    return toHeaderString(this._response.headers);\n  }\n  \n  public abort() {\n    // According to https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request ,\n    // it should throw an Error on abort() called when using synchronous request.\n    // However, it actually does not in some major browser.\n    /*\n    if(this._request.async === false){\n      throw new Error(\"Invalid access error\");\n    }\n   */\n    \n    this._isAborted = true;\n    this.status = 0;\n    this.readyState = this.UNSENT;\n    this._readyState = this.UNSENT;\n    \n    if(this._transitioning){\n      this._xhr.abort();\n    }\n    else{\n      this.dispatchEvent(makeProgressEvent(\"abort\", 0));\n    }\n    \n    this._transitioning = false;\n  }\n  \n  private static _createRequest(xhr: XMLHttpRequest): XhrRequest {\n    return {\n      ajaxType: \"xhr\" as const,\n      headers: {},\n      method: \"GET\",\n      url: \"\",\n      async: true,\n      timeout: 0,\n      upload: xhr.upload,\n    };\n  }\n  \n  private static _createResponse(){\n    return {\n      ajaxType: \"xhr\" as const,\n      status: 0,\n      statusText: \"\",\n      finalUrl: \"\",\n      responseType: \"\" as const,\n      headers: {},\n    };\n  }\n  \n  private _setupVirtualRequestForSending(body?: Document | BodyInit | null){\n    this._request.responseType = this.responseType;\n    this._request.timeout = this.timeout;\n    this._request.withCredentials = this.withCredentials;\n    this._request.body = body;\n    this._xhr.onabort = typeof(this.onabort) === \"function\" ? this.onabort.bind(this) : null;\n    this._xhr.onerror = typeof(this.onerror) === \"function\" ? this.onerror.bind(this) : null;\n    this._xhr.ontimeout = typeof(this.ontimeout) === \"function\" ? this.ontimeout.bind(this) : null;\n    this._xhr.onprogress = typeof(this.onprogress) === \"function\" ? this.onprogress.bind(this) : null;\n  }\n  \n  private _syncEventListenersToXHR(){\n    const addEventListeners = <K extends keyof XMLHttpRequestEventMap>(type: K) => {\n      const localListeners = this._listeners[type];\n      if(!localListeners || localListeners.length < 1){\n        return;\n      }\n    \n      for(let i=0;i<localListeners.length;i++){\n        this._xhr.addEventListener(type, localListeners[i].bind(this));\n      }\n    };\n  \n    addEventListeners(\"abort\");\n    addEventListeners(\"error\");\n    addEventListeners(\"timeout\");\n    addEventListeners(\"progress\");\n  }\n  \n  private _createRequestCallback(onCalled: () => unknown) : RequestCallback<\"xhr\"> {\n    type RequestCallbackOnlyWithDefaultFunc = {\n      (dummyResponse: XhrResponse): unknown;\n      moveToHeaderReceived?: (dummyResponse: XhrResponse) => void;\n      moveToLoading?: (dummyResponse: XhrResponse) => void;\n    };\n    \n    const cb: RequestCallbackOnlyWithDefaultFunc = (response: XhrResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n      \n      this.dispatchEvent(makeProgressEvent(\"loadstart\", 0));\n  \n      this._response = {\n        ...this._response,\n        ...response,\n      };\n  \n      this._runUntil(this.DONE);\n  \n      onCalled();\n    };\n    \n    const moveToHeaderReceived = (response: XhrResponse) => {\n      if(this.readyState >= this.HEADERS_RECEIVED){\n        return;\n      }\n      this._response = {\n        ...this._response,\n        ...response,\n      };\n      this._runUntil(this.HEADERS_RECEIVED);\n    };\n    \n    const moveToLoading = (response: XhrResponse) => {\n      if(this.readyState >= this.LOADING){\n        return;\n      }\n      this._response = {\n        ...this._response,\n        ...response,\n      };\n      this._runUntil(this.LOADING);\n    };\n    \n    cb.moveToHeaderReceived = moveToHeaderReceived;\n    cb.moveToLoading = moveToLoading;\n    \n    return cb as RequestCallback<\"xhr\">;\n  }\n  \n  private _createResponseCallback(onCalled: () => unknown) : ResponseCallback<\"xhr\"> {\n    return (response: XhrResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n      \n      this._response = {\n        ...this._response,\n        ...response,\n      };\n      \n      onCalled();\n    };\n  }\n  \n  private _loadHeaderFromXHRToVirtualResponse(){\n    this._response.status = this._xhr.status;\n    if(!this._isAborted){\n      this._response.statusText = this._xhr.statusText;\n    }\n    else{\n      return;\n    }\n    \n    const responseHeaders = this._xhr.getAllResponseHeaders();\n    const headerMap = toHeaderMap(responseHeaders);\n  \n    const keys = Object.keys(headerMap);\n    for(let i=0;i<keys.length;i++){\n      const key = keys[i];\n      const value = headerMap[key];\n      if(!this._response.headers[key]){\n        this._response.headers[key] = value;\n      }\n    }\n  }\n  \n  private _loadBodyFromXHRToVirtualResponse(){\n    if(!this._xhr.responseType){\n      this._response.responseText = this._xhr.responseText;\n      this._response.responseXML = this._xhr.responseXML;\n      this._response.response = this._xhr.responseText;\n    }\n    else if(this._xhr.responseType === \"text\"){\n      this._response.responseText = this._xhr.responseText;\n      this._response.response = this._xhr.responseText;\n    }\n    else if(this._xhr.responseType === \"document\"){\n      this._response.responseXML = this._xhr.responseXML;\n      this._response.response = this._xhr.responseXML;\n    }\n    else{\n      this._response.response = this._xhr.response;\n    }\n    \n    if(\"responseURL\" in this._xhr){\n      this._response.responseURL = this._xhr.responseURL;\n    }\n  }\n  \n  private _syncHeaderFromVirtualResponse(){\n    this.status = this._response.status;\n    this.statusText = this._response.statusText;\n    // Response headers will be requested via getResponseHeader/getAllResponseHeaders\n    // which get header values directly from this._response.\n  }\n  \n  private _syncBodyFromVirtualResponse(){\n    if(\"responseText\" in this._response){\n      this._responseText = this._response.responseText || \"\";\n    }\n    if(\"responseXML\" in this._response){\n      this._responseXML = this._response.responseXML || null;\n    }\n    if(\"body\" in this._response){\n      this.response = this._response.body || null;\n    }\n    if(\"response\" in this._response){\n      this.response = this._response.response;\n    }\n    if(\"responseURL\" in this._response){\n      this.responseURL = this._response.responseURL || \"\";\n    }\n  }\n  \n  private _onError(){\n    this._hasError = true;\n    this._readyState = this.UNSENT;\n    this.readyState = this.UNSENT;\n    this.status = 0;\n  }\n  \n  private _triggerStateAction(){\n    const readyStateChangeEvent = createEvent(\"readystatechange\");\n    \n    if(this._readyState === this.OPENED){\n      this.dispatchEvent(readyStateChangeEvent);\n    }\n    else if(this._readyState === this.HEADERS_RECEIVED){\n      this._syncHeaderFromVirtualResponse();\n      this.dispatchEvent(readyStateChangeEvent);\n    }\n    else if(this._readyState === this.LOADING){\n      this._syncHeaderFromVirtualResponse();\n      this.dispatchEvent(readyStateChangeEvent);\n    }\n    else if(this._readyState === this.DONE){\n      this._syncHeaderFromVirtualResponse();\n      this._syncBodyFromVirtualResponse();\n      \n      let isReturnResponseCalled = false;\n      \n      const returnResponse = () => {\n        isReturnResponseCalled = true;\n        \n        // Re-sync for a case that this._request/this._response is modified in callback\n        this._syncHeaderFromVirtualResponse();\n        this._syncBodyFromVirtualResponse();\n  \n        this.dispatchEvent(readyStateChangeEvent);\n  \n        const emitLoadEvent = () => {\n          if(!this._hasError){\n            this.dispatchEvent(makeProgressEvent(\"load\", 0));\n          }\n          this.dispatchEvent(makeProgressEvent(\"loadend\", 0));\n        };\n  \n        if(this._request.async === false){\n          emitLoadEvent();\n        }\n        else{\n          window.setTimeout(emitLoadEvent, 0);\n        }\n      };\n  \n      const listeners = Proxy.getResponseListeners();\n      let listenerPointer = 0;\n  \n      const executeNextListener = (): unknown => {\n        try{\n          if(listenerPointer >= listeners.length){\n            return returnResponse();\n          }\n      \n          const l = listeners[listenerPointer];\n      \n          // l: (request, response, callback) => unknown\n          if(l.length >= 3){\n            const userCallback = this._createResponseCallback(() => {\n              listenerPointer++;\n              executeNextListener();\n            });\n        \n            l.call(this, this._request, this._response, userCallback);\n            return;\n          }\n      \n          // l: (request, response) => unknown\n          l.call(this, this._request, this._response);\n      \n          listenerPointer++;\n          executeNextListener();\n        }\n        catch(e){\n          console.warn(\"XMLHttpRequest: Exception in response handler\", e);\n      \n          if(!isReturnResponseCalled){\n            listenerPointer++;\n            executeNextListener();\n          }\n        }\n      };\n  \n      executeNextListener();\n    }\n  }\n  \n  private _runUntil(state: number){\n    while(this._readyState < state && this._readyState < this.DONE){\n      this._readyState++;\n      this.readyState = this._readyState;\n    \n      this._triggerStateAction();\n    }\n  }\n}\n","export class ResponseProxy {\n  private _response: Response;\n  private _body?: BodyInit | null;\n  private _init?: ResponseInit;\n  \n  public headers: Headers;\n  public ok: boolean;\n  public redirected: boolean;\n  public status: number;\n  public statusText: string;\n  public trailer: Promise<Headers>;\n  public type: ResponseType;\n  public url: string;\n  \n  public body: ReadableStream<Uint8Array> | null;\n  public bodyUsed: boolean;\n  \n  public constructor(body?: BodyInit | null, init?: ResponseInit) {\n    this._response = new Response(body, init);\n    this._body = body;\n    this._init = init;\n  \n    this.headers = new Headers(init ? init.headers : undefined);\n    this.ok = false;\n    this.redirected = false;\n    this.status = init && init.status ? init.status : 0;\n    this.statusText = init && init.statusText ? init.statusText : \"\";\n    this.trailer = this._response.trailer;\n    this.type = \"basic\";\n    this.url = \"\";\n    \n    this.body = this._response.body;\n    this.bodyUsed = this._response.bodyUsed;\n  }\n  \n  public static error(){\n    return Response.error();\n  }\n  \n  public static redirect(url: string, status?: number){\n    return Response.redirect(url, status);\n  }\n  \n  public clone(){\n    return new ResponseProxy(this._body, this._init);\n  }\n  \n  public arrayBuffer(){\n    return this._response.arrayBuffer();\n  }\n  \n  public blob(){\n    return this._response.blob();\n  }\n  \n  public formData(){\n    return this._response.formData();\n  }\n  \n  public json(){\n    return this._response.json();\n  }\n  \n  public text(){\n    return this._response.text();\n  }\n}\n","import {Proxy} from \"../Proxy\";\nimport {FetchRequest, FetchResponse, RequestCallback, ResponseCallback, TResponse} from \"../index.type\";\nimport {ResponseProxy} from \"./Response\";\n\nclass FetchProxy {\n  private _request: FetchRequest;\n  private _response: FetchResponse;\n  private _input?: RequestInfo;\n  private _init?: RequestInit;\n  \n  public constructor(input: RequestInfo, init?: RequestInit) {\n    this._input = input;\n    this._init = init;\n  \n    this.dispatch = this.dispatch.bind(this);\n    this._onResponse = this._onResponse.bind(this);\n    this._createRequestCallback = this._createRequestCallback.bind(this);\n    this._createResponseCallback = this._createResponseCallback.bind(this);\n    \n    this._request = FetchProxy._createRequest(input, init);\n    this._response = FetchProxy._createResponse();\n  }\n  \n  public dispatch(): Promise<Response> {\n    return new Promise((resolve, reject) => {\n      const originalResponse = this._response;\n      let isDispatchFetchCalled = false;\n      \n      const dispatchFetch = () => {\n        isDispatchFetchCalled = true;\n        \n        if(originalResponse !== this._response){\n          this._onResponse().then((response) => {\n            resolve(response);\n          });\n          return;\n        }\n        \n        Proxy.OriginalFetch(this._request.url, this._request).then(response => {\n          const headers: Record<string, string> = {};\n          for(const key of response.headers.keys()){\n            const value = response.headers.get(key)\n            if(value){\n              headers[key] = value;\n            }\n          }\n          \n          this._response = {\n            ajaxType: \"fetch\",\n            status: response.status,\n            statusText: response.statusText,\n            headers,\n            ok: response.ok,\n            redirected: response.redirected,\n            type: response.type,\n            url: response.url,\n            body: response.body,\n          };\n          \n          this._onResponse().then(r => {\n            resolve(r);\n          });\n        });\n      };\n  \n      const requestListeners = Proxy.getRequestListeners();\n      let listenerPointer = 0;\n  \n      const executeNextListener = (): unknown => {\n        try{\n          if(listenerPointer >= requestListeners.length){\n            return dispatchFetch();\n          }\n      \n          const l = requestListeners[listenerPointer];\n      \n          // l: (request, callback) => unknown\n          if(l.length >= 2){\n            const userCallback = this._createRequestCallback(() => {\n              listenerPointer++;\n              executeNextListener();\n            });\n        \n            l.call({}, this._request, userCallback as RequestCallback<\"xhr\"|\"fetch\">);\n            return;\n          }\n      \n          // l: (request) => unknown\n          l.call({}, this._request);\n      \n          listenerPointer++;\n          executeNextListener();\n        }\n        catch(e){\n          console.warn(\"XMLHttpRequest: Exception in request handler\", e);\n      \n          if(!isDispatchFetchCalled){\n            listenerPointer++;\n            executeNextListener();\n          }\n        }\n      };\n  \n      executeNextListener();\n    });\n  }\n  \n  private _onResponse(){\n    return new Promise<Response>((resolve => {\n      let isReturnResponseCalled = false;\n  \n      const returnResponse = () => {\n        isReturnResponseCalled = true;\n        const res = new ResponseProxy(this._response.body, this._response);\n        res.url = this._response.url;\n        res.type = this._response.type;\n        res.redirected = this._response.redirected;\n        res.ok = this._response.ok;\n        resolve(res);\n      };\n  \n      const responseListeners = Proxy.getResponseListeners();\n      let listenerPointer = 0;\n  \n      const executeNextListener = (): unknown => {\n        try{\n          if(listenerPointer >= responseListeners.length){\n            return returnResponse();\n          }\n      \n          const l = responseListeners[listenerPointer];\n      \n          // l: (request, response, callback) => unknown\n          if(l.length >= 3){\n            const userCallback = this._createResponseCallback(() => {\n              listenerPointer++;\n              executeNextListener();\n            });\n        \n            l.call({}, this._request, this._response, userCallback);\n            return;\n          }\n      \n          // l: (request, response) => unknown\n          l.call({}, this._request, this._response);\n      \n          listenerPointer++;\n          executeNextListener();\n        }\n        catch(e){\n          console.warn(\"XMLHttpRequest: Exception in request handler\", e);\n      \n          if(!isReturnResponseCalled){\n            listenerPointer++;\n            executeNextListener();\n          }\n        }\n      };\n  \n      executeNextListener();\n    }));\n  }\n  \n  private static _createRequest(input: RequestInfo, init?: RequestInit): FetchRequest {\n    if(typeof input === \"string\"){\n      const req = {\n        ...(init||{}),\n        ajaxType: \"fetch\",\n        headers: {},\n        url: input,\n      } as FetchRequest;\n      \n      if(init && init.headers){\n        const headers = init.headers instanceof Headers ? init.headers : new Headers(init.headers);\n  \n        /**\n         * Webpack's es5 output for `for-of` loop over iterable does not work as expected as of 2020/08/08.\n         * \n         * for(const pair of headers.entries()){\n         *   ...\n         * }\n         * \n         * will be converted to\n         * \n         * for (var _i = 0, _a = headers.entries(); _i < _a.length; _i++) {\n         *   ...\n         * }\n         * \n         * Since headers.entries() returns not an array but iterable, `_a.length` is undefined.\n         * So the loop never run.\n         * As a work around, I convert iterable to an array as below.\n         */\n        const entries = Array.from(headers.entries());\n        for(let i=0;i<entries.length;i++){\n          const pair = entries[i];\n          const key = pair[0];\n          const value = pair[1];\n          if(value){\n            req.headers[key] = value;\n          }\n        }\n      }\n      \n      return req;\n    }\n    else{\n      const headers = input.headers || (init && init.headers ? init.headers : null);\n      \n      const req = {\n        ...(init||{}),\n        ajaxType: \"fetch\",\n        method: input.method,\n        url: input.url,\n        timeout: 0,\n        headers: {},\n        // input.body may be `undefined` since major browsers does not support it as of 2020/08/06.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#bcd:api.Request.Request\n        body: input.body,\n        cache: input.cache,\n        credentials: input.credentials,\n        integrity: input.integrity,\n        keepalive: input.keepalive,\n        mode: input.mode,\n        redirect: input.redirect,\n        referrer: input.referrer,\n        referrerPolicy: input.referrerPolicy,\n        signal: input.signal,\n      } as FetchRequest;\n  \n      if(headers){\n        const entries = Array.from(headers.entries());\n        for(let i=0;i<entries.length;i++){\n          const pair = entries[i];\n          const key = pair[0];\n          const value = pair[1];\n          if(value){\n            req.headers[key] = value;\n          }\n        }\n      }\n      \n      return req;\n    }\n  }\n  \n  private static _createResponse(): FetchResponse {\n    return {\n      ajaxType: \"fetch\",\n      status: 0,\n      statusText: \"\",\n      headers: {},\n      ok: true,\n      redirected: false,\n      type: \"basic\",\n      url: \"\",\n      body: null,\n    };\n  }\n  \n  private _createRequestCallback(onCalled: () => unknown): RequestCallback<\"fetch\"> {\n    type RequestCallbackOnlyWithDefaultFunc = {\n      (dummyResponse: FetchResponse): unknown;\n      moveToHeaderReceived?: (dummyResponse: TResponse<\"fetch\">) => void;\n      moveToLoading?: (dummyResponse: TResponse<\"fetch\">) => void;\n    };\n  \n    const cb: RequestCallbackOnlyWithDefaultFunc = (response: FetchResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n  \n      this._response = response;\n      onCalled();\n    };\n    \n    cb.moveToHeaderReceived = () => { return; };\n    cb.moveToLoading = () => { return; };\n    \n    return cb as RequestCallback<\"fetch\">;\n  }\n  \n  private _createResponseCallback(onCalled: () => unknown) : ResponseCallback<\"fetch\"> {\n    return (response: FetchResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n      \n      this._response = response;\n      \n      onCalled();\n    };\n  }\n  \n}\n\nexport function fetchProxy(input: RequestInfo, init?: RequestInit): Promise<Response> {\n  const fetch = new FetchProxy(input, init);\n  return fetch.dispatch();\n}","import {Proxy} from \"./Proxy\";\nimport {WindowEx} from \"./index.type\";\nimport {XHRProxy} from \"./modules/XMLHttpRequest\";\nimport {fetchProxy} from \"./modules/fetch\";\n\ndeclare let window: WindowEx;\n\nProxy.setXMLHttpRequest(XHRProxy);\nProxy.setFetch(fetchProxy);\nProxy.enable();\n\nexport default Proxy;\n"],"sourceRoot":""}