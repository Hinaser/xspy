{"version":3,"sources":["webpack://xspy/webpack/universalModuleDefinition","webpack://xspy/webpack/bootstrap","webpack://xspy/./src/Proxy.ts","webpack://xspy/./src/index.lib.ts","webpack://xspy/./src/modules/XMLHttpRequest.ts","webpack://xspy/./src/modules/Response.ts","webpack://xspy/./src/modules/fetch.ts","webpack://xspy/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Proxy","XMLHttpRequest","_customXHR","fetch","_customFetch","OriginalXHR","OriginalFetch","_reqListeners","slice","_resListeners","listener","listeners","this","indexOf","splice","push","_removeEventListener","clearRequestHandler","clearResponseHandler","type","length","userAgent","navigator","IEVersion","version","parseInt","exec","toLowerCase","isNaN","isIE","op","createEvent","Event","ev","document","initEvent","e","makeProgressEvent","loaded","lengthComputable","total","target","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","_xhr","_listeners","_readyState","_isAborted","_hasError","_transitioning","_request","_createRequest","_response","_createResponse","_responseText","_responseXML","readyState","status","statusText","timeout","upload","response","responseType","responseURL","withCredentials","onreadystatechange","onabort","onerror","onloadstart","onload","onloadend","ontimeout","onprogress","_init","Error","_onError","_createRequestCallback","addEventListener","realReadyState","async","_loadHeaderFromXHRToVirtualResponse","_loadBodyFromXHRToVirtualResponse","_runUntil","options","index","event","TypeError","onHandlerPropName","handler","mime","overrideMimeType","method","url","username","password","arguments","headers","body","DOMException","_setupVirtualRequestForSending","_syncEventListenersToXHR","isDispatchXHRSendCalled","dispatchXHRSend","open","dispatchEvent","headerMap","headerNames","keys","headerName","headerValue","setRequestHeader","send","getRequestListeners","listenerPointer","executeNextListener","userCallback","console","warn","lowerName","lowerHeaderName","join","toHeaderString","abort","xhr","ajaxType","finalUrl","addEventListeners","localListeners","onCalled","cb","moveToHeaderReceived","moveToLoading","responseHeaders","trim","split","map","parts","shift","toHeaderMap","getAllResponseHeaders","responseText","responseXML","readyStateChangeEvent","_syncHeaderFromVirtualResponse","_syncBodyFromVirtualResponse","isReturnResponseCalled","returnResponse","emitLoadEvent","setTimeout","getResponseListeners","_createResponseCallback","state","_triggerStateAction","ResponseProxy","init","Response","_body","Headers","undefined","ok","redirected","trailer","bodyUsed","error","redirect","arrayBuffer","blob","formData","json","text","input","_input","dispatch","_onResponse","Promise","resolve","reject","originalResponse","isDispatchFetchCalled","dispatchFetch","then","requestListeners","res","responseListeners","req","entries","Array","from","pair","cache","credentials","integrity","keepalive","referrer","referrerPolicy","signal","setXMLHttpRequest","setFetch","enable"],"mappings":"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","file":"xspy.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"xspy\"] = factory();\n\telse\n\t\troot[\"xspy\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {EventType, RequestHandler, ResponseHandler, WindowEx} from \"./index.type\";\n\ndeclare let window: WindowEx;\n\nexport class Proxy {\n  private static _reqListeners: Array<RequestHandler<\"xhr\"|\"fetch\">> = [];\n  private static _resListeners: Array<ResponseHandler<\"xhr\"|\"fetch\">> = [];\n  private static _customXHR = window.XMLHttpRequest;\n  private static _customFetch = window.fetch;\n  public static readonly OriginalXHR = window.XMLHttpRequest;\n  /* Only IE does not implement `window.fetch`. Exclude from coverage counting. */\n  /* istanbul ignore next */\n  public static readonly OriginalFetch = (window.fetch || function fetch(){ return; }).bind(window);\n  \n  public static enable() {\n    window.XMLHttpRequest = Proxy._customXHR;\n    /* istanbul ignore else */\n    if(window.fetch){\n      window.fetch = Proxy._customFetch;\n    }\n  }\n  \n  public static disable() {\n    window.XMLHttpRequest = Proxy.OriginalXHR;\n    /* istanbul ignore else */\n    if(window.fetch && Proxy.OriginalFetch){\n      window.fetch = Proxy.OriginalFetch;\n    }\n  }\n  \n  public static isEnabled(){\n    return window.XMLHttpRequest === Proxy._customXHR;\n  }\n  \n  public static setXMLHttpRequest(m: typeof window[\"XMLHttpRequest\"]){\n    Proxy._customXHR = m;\n  }\n  \n  public static setFetch(m: typeof window[\"fetch\"]){\n    Proxy._customFetch = m;\n  }\n  \n  public static getRequestListeners() {\n    const listeners = Proxy._reqListeners;\n    return listeners.slice();\n  }\n  \n  public static getResponseListeners() {\n    const listeners = Proxy._resListeners;\n    return listeners.slice();\n  }\n  \n  public static onRequest(listener: RequestHandler<\"xhr\"|\"fetch\">, n?: number) {\n    const listeners = this._reqListeners;\n    if (listeners.indexOf(listener) > -1) {\n      return;\n    }\n  \n    if (typeof n === \"number\") {\n      listeners.splice(n, 0, listener);\n    } else {\n      listeners.push(listener);\n    }\n  }\n  \n  public static offRequest(listener: RequestHandler<\"xhr\"|\"fetch\">) {\n    this._removeEventListener(\"request\", listener);\n  }\n  \n  public static onResponse(listener: ResponseHandler<\"xhr\"|\"fetch\">, n?: number) {\n    const listeners = this._resListeners;\n    if (listeners.indexOf(listener) > -1) {\n      return;\n    }\n  \n    if (typeof n === \"number\") {\n      listeners.splice(n, 0, listener);\n    } else {\n      listeners.push(listener);\n    }\n  }\n  \n  public static offResponse(listener: ResponseHandler<\"xhr\"|\"fetch\">) {\n    this._removeEventListener(\"response\", listener);\n  }\n  \n  public static clearAll() {\n    Proxy.clearRequestHandler();\n    Proxy.clearResponseHandler();\n  }\n  \n  public static clearRequestHandler() {\n    this._reqListeners = [];\n  }\n  \n  public static clearResponseHandler() {\n    this._resListeners = [];\n  }\n  \n  private static _removeEventListener(type: EventType, listener: RequestHandler<\"xhr\"|\"fetch\"> | ResponseHandler<\"xhr\"|\"fetch\">) {\n    const listeners = type === \"request\" ? this._reqListeners : this._resListeners;\n    \n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener) {\n        listeners.splice(i, 1);\n        return;\n      }\n    }\n  }\n}\n","const userAgent = typeof navigator !== \"undefined\" && navigator.userAgent ? navigator.userAgent : \"\";\n\n// If browser is not IE, IEVersion will be NaN\nexport const IEVersion = (() => {\n  let version = parseInt((/msie (\\d+)/.exec(userAgent.toLowerCase()) || [])[1], 10);\n  \n  /* istanbul ignore else */\n  if(isNaN(version)) {\n    version = parseInt((/trident\\/.*; rv:(\\d+)/.exec(userAgent.toLowerCase()) || [])[1], 10);\n    /* istanbul ignore else */\n    if(isNaN(version)){\n      return false;\n    }\n    /* istanbul ignore next */\n    return version;\n  }\n  \n  /* istanbul ignore next */\n  return version;\n})();\n\n/* istanbul ignore next */\nexport function isIE(op?: \"<\"|\"<=\"|\">\"|\">=\"|\"=\", version?: number){\n  if(IEVersion === false) return false;\n  else if(!version) return true;\n  else if(op === \"<\") return IEVersion < version;\n  else if(op === \"<=\") return IEVersion <= version;\n  else if(op === \">\") return IEVersion > version;\n  else if(op === \">=\") return IEVersion >= version;\n  else if(op === \"=\") return IEVersion === version;\n  return IEVersion === version;\n}\n\nexport const createEvent = (type: string): Event => {\n  try{\n    /* istanbul ignore else */\n    if(!isIE() && typeof Event !== \"undefined\"){\n      return new Event(type);\n    }\n    \n    // When browser is IE, `new Event()` will fail.\n    /* istanbul ignore next */\n    const ev = window.document.createEvent(\"Event\");\n    /* istanbul ignore next */\n    ev.initEvent(type);\n    /* istanbul ignore next */\n    return ev;\n  }\n  catch(e){\n    /* istanbul ignore next */\n    return {\n      type,\n    } as Event;\n  }\n};\n\nexport const toHeaderMap = (responseHeaders: string) => {\n  const headers = responseHeaders.trim().split(/[\\r\\n]+/)\n  \n  const map: {[name: string]: string} = {};\n  for(let i=0;i<headers.length;i++){\n    const line = headers[i];\n    const parts = line.split(\": \");\n    const name = parts.shift();\n    if(name){\n      const lowerName = name.toLowerCase();\n      map[lowerName] = parts.join(\": \");\n    }\n  }\n  \n  return map;\n}\n\nexport const toHeaderString = (headerMap: {[name: string]: string}) => {\n  const headers: string[] = [];\n  const keys = Object.keys(headerMap);\n  \n  for(let i=0;i<keys.length;i++){\n    const key = keys[i];\n    const name = key.toLowerCase();\n    const value = headerMap[key];\n    \n    headers.push(name + \": \" + value);\n  }\n  \n  return headers.join(\"\\r\\n\") + \"\\r\\n\";\n};\n\nexport const makeProgressEvent = (type: string, loaded: number, lengthComputable: boolean = false, total: number = 0) => {\n  const ev: ProgressEvent<XMLHttpRequestEventTarget> = {\n    ...createEvent(type),\n    type,\n    target: null,\n    loaded,\n    lengthComputable,\n    total,\n  };\n  \n  return ev;\n}\n","import {RequestCallback, ResponseCallback, XhrRequest, XhrResponse} from \"../index.type\";\nimport {createEvent, makeProgressEvent, toHeaderMap, toHeaderString, isIE} from \"../index.lib\";\nimport {Proxy} from \"../Proxy\";\n\nexport class XHRProxy implements XMLHttpRequest {\n  static readonly UNSENT: number = 0;\n  static readonly OPENED: number = 1;\n  static readonly HEADERS_RECEIVED: number = 2;\n  static readonly LOADING: number = 3;\n  static readonly DONE: number = 4;\n  \n  public readonly UNSENT: number = 0;\n  public readonly OPENED: number = 1;\n  public readonly HEADERS_RECEIVED: number = 2;\n  public readonly LOADING: number = 3;\n  public readonly DONE: number = 4;\n  \n  private _xhr = new Proxy.OriginalXHR();\n  private _listeners: {[type: string]: Array<(this: XMLHttpRequest, ev: Event|ProgressEvent<XMLHttpRequestEventTarget>) => unknown>} = {};\n  private _readyState: number = 0;\n  private _isAborted: boolean = false;\n  private _hasError: boolean|null = null;\n  private _transitioning: boolean|null = null;\n  private _request: XhrRequest = XHRProxy._createRequest(this._xhr);\n  private _response: XhrResponse = XHRProxy._createResponse();\n  private _responseText: string = \"\";\n  private _responseXML: Document | null = null;\n  \n  public readyState = 0;\n  public status = 0;\n  public statusText = \"\";\n  public timeout: number = 0;\n  public readonly upload = this._xhr.upload;\n  \n  public response: BodyInit|Document|null|undefined = \"\";\n  public responseType: XMLHttpRequestResponseType = \"\";\n  public responseURL: string = \"\";\n  public get responseText(): string {\n    if(this.responseType === \"text\" || this.responseType === \"\"){\n      return this._responseText;\n    }\n    /* istanbul ignore next */\n    else if(isIE(\">=\", 10)){\n      return this._responseText;\n    }\n    const e = new Error(\"responseText is only available if responseType is '' or 'text'.\");\n    e.name = \"InvalidStateError\";\n    throw e;\n  }\n  public get responseXML(): Document | null {\n    if(this.responseType === \"document\" || this.responseType === \"\"){\n      return this._responseXML;\n    }\n    /* istanbul ignore next */\n    else if(isIE(\">=\", 10)){\n      return this._responseXML;\n    }\n    const e = new Error(\"responseXML is only available if responseType is '' or 'document'.\");\n    e.name = \"InvalidStateError\";\n    throw e;\n  }\n  public withCredentials: boolean = false;\n  \n  public onreadystatechange: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onabort: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onerror: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onloadstart: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onload: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onloadend: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public ontimeout: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  public onprogress: ((this: XMLHttpRequest, ev: Event) => unknown) | null = null;\n  \n  constructor() {\n    this._init();\n  }\n  \n  private _init(){\n    this._onError = this._onError.bind(this);\n    this._createRequestCallback = this._createRequestCallback.bind(this);\n  \n    const addEventListener = <K extends keyof XMLHttpRequestEventMap>(type: K) => {\n      this.addEventListener(type, this._onError);\n    }\n    addEventListener(\"error\");\n    addEventListener(\"timeout\");\n    addEventListener(\"abort\");\n    \n    this._xhr.onreadystatechange = () => {\n      // According to https://xhr.spec.whatwg.org/#the-abort()-method\n      // onreadystatechange should not be called,\n      // but some major browsers seems to call it actually.\n      /*\n      if(this._isAborted){\n        return;\n      }\n      */\n  \n      const realReadyState = this._xhr.readyState;\n      \n      if(realReadyState === this.HEADERS_RECEIVED){\n        /* istanbul ignore if */\n        if(isIE(\"<=\", 9) && /* istanbul ignore next */ this._request.async === false){\n          // For synchronous request in IE <= 9, it throws Error when accessing xhr header if readyState is less than LOADING.\n          // this._loadHeaderFromXHRToVirtualResponse();\n        }\n        else{\n          this._loadHeaderFromXHRToVirtualResponse();\n        }\n      }\n      else if(realReadyState === this.LOADING){\n        this._loadHeaderFromXHRToVirtualResponse();\n      }\n      else if(realReadyState === this.DONE){\n        this._transitioning = false;\n        this._loadHeaderFromXHRToVirtualResponse();\n        this._loadBodyFromXHRToVirtualResponse();\n      }\n      \n      this._runUntil(realReadyState);\n    };\n  }\n  \n  public addEventListener<K extends keyof XMLHttpRequestEventMap>(\n    type: K,\n    listener: (this: XMLHttpRequest, ev: Event|ProgressEvent<XMLHttpRequestEventTarget>) => unknown,\n    options?: boolean | AddEventListenerOptions\n  ){\n    if(!this._listeners[type]){\n      this._listeners[type] = [];\n    }\n    \n    this._listeners[type].push(listener);\n  }\n  \n  public removeEventListener<K extends keyof XMLHttpRequestEventMap>(\n    type: K,\n    listener: (this: XMLHttpRequest, ev: Event|ProgressEvent<XMLHttpRequestEventTarget>) => any,\n    options?: boolean | EventListenerOptions\n  ){\n    if(!this._listeners[type]){\n      return;\n    }\n    \n    const index = this._listeners[type].indexOf(listener);\n    if(index < 0){\n      return;\n    }\n    \n    this._listeners[type].splice(index, 1);\n  }\n  \n  public dispatchEvent(event: Event|ProgressEvent<XMLHttpRequestEventTarget>){\n    if(typeof event !== \"object\"){\n      throw new TypeError(\"EventTarget.dispatchEvent: Argument 1 is not an object\");\n    }\n    \n    const onHandlerPropName = \"on\" + event.type;\n    if(onHandlerPropName === \"onabort\"\n      || onHandlerPropName === \"onerror\"\n      || onHandlerPropName === \"onload\"\n      || onHandlerPropName === \"onloadend\"\n      || onHandlerPropName === \"onloadstart\"\n      || onHandlerPropName === \"onprogress\"\n      || onHandlerPropName === \"ontimeout\"\n    ){\n      const handler = this[onHandlerPropName];\n      if(handler){\n        handler.call(this, event as ProgressEvent<XMLHttpRequestEventTarget>);\n      }\n    }\n    else if(onHandlerPropName === \"onreadystatechange\"){\n      const handler = this[onHandlerPropName];\n      if(handler){\n        handler.call(this, event as Event);\n      }\n    }\n    \n    const listeners = this._listeners[event.type];\n    if(!listeners){\n      return true;\n    }\n    \n    for(let i=0;i<listeners.length;i++){\n      const l = listeners[i];\n      l.call(this, event);\n    }\n    return true;\n  }\n  \n  public overrideMimeType(mime: string) {\n    return this._xhr.overrideMimeType.call(this._xhr, mime);\n  }\n  \n  public open(method: string, url: string, async?: boolean, username?: string|null, password?: string|null){\n    if(arguments.length < 2){\n      throw new TypeError(\"XMLHttpRequest.open: \" + arguments.length + \" is not a valid argument count for any overload\");\n    }\n    \n    this._readyState = 0;\n    this._hasError = false;\n    this._isAborted = false;\n    this._transitioning = false;\n    \n    this._request = {\n      ...XHRProxy._createRequest(this._xhr),\n      headers: {},\n      method,\n      url,\n      async: async !== false,\n      username,\n      password,\n    };\n    \n    this._response = {\n      ...XHRProxy._createResponse(),\n      headers: {},\n    };\n    \n    this._runUntil(this.OPENED);\n  }\n  \n  public send(body?: Document | BodyInit | null) {\n    if(this._readyState !== this.OPENED){\n      throw new DOMException(\"XMLHttpRequest state must be OPENED\");\n    }\n  \n    this._setupVirtualRequestForSending(body);\n    this._syncEventListenersToXHR();\n    \n    let isDispatchXHRSendCalled = false;\n  \n    const dispatchXHRSend = () => {\n      isDispatchXHRSendCalled = true;\n      \n      // When requestCallback is used, readystate is automatically move forward to 'DONE'\n      // and produce dummy response.\n      if(this._readyState === this.DONE){\n        return;\n      }\n    \n      this._transitioning = true;\n      \n      const async = this._request.async !== false;\n    \n      this._xhr.open(\n        this._request.method,\n        this._request.url,\n        async,\n        this._request.username,\n        this._request.password\n      );\n    \n      if(async){\n        this._xhr.responseType = this.responseType;\n        this._xhr.timeout = this.timeout;\n      }\n      this._xhr.withCredentials = this.withCredentials;\n    \n      this.dispatchEvent(makeProgressEvent(\"loadstart\", 0));\n    \n      const headerMap = this._request.headers;\n      const headerNames = headerMap ? Object.keys(headerMap) : [];\n      for(let i=0;i<headerNames.length;i++){\n        const headerName = headerNames[i];\n        const headerValue = headerMap[headerName];\n        this._xhr.setRequestHeader(headerName, headerValue);\n      }\n    \n      this._xhr.send(this._request.body);\n    };\n  \n    const listeners = Proxy.getRequestListeners();\n    let listenerPointer = 0;\n  \n    const executeNextListener = (): unknown => {\n      try{\n        if(listenerPointer >= listeners.length){\n          return dispatchXHRSend();\n        }\n      \n        const l = listeners[listenerPointer];\n      \n        // l: (request, callback) => unknown\n        if(l.length >= 2){\n          const userCallback = this._createRequestCallback(() => {\n            listenerPointer++;\n            executeNextListener();\n          });\n        \n          l.call(this, this._request, userCallback as RequestCallback<\"xhr\"|\"fetch\">);\n          return;\n        }\n      \n        // l: (request) => unknown\n        l.call(this, this._request);\n      \n        listenerPointer++;\n        executeNextListener();\n      }\n      catch(e){\n        console.warn(\"XMLHttpRequest: Exception in request handler\", e);\n      \n        if(!isDispatchXHRSendCalled){\n          listenerPointer++;\n          executeNextListener();\n        }\n      }\n    };\n  \n    executeNextListener();\n  }\n  \n  public setRequestHeader(name: string, value: string) {\n    if(this.readyState !== this.OPENED){\n      throw new DOMException(\"XMLHttpRequest state must be OPENED\");\n    }\n    \n    if(!this._request.headers){\n      this._request.headers = {};\n    }\n    \n    const lowerName = name.toLowerCase();\n    if(this._request.headers[lowerName]){\n      value = this._request.headers[lowerName] + \", \" + value;\n    }\n    \n    this._request.headers[lowerName] = value;\n  }\n  \n  public getResponseHeader(name: string): string | null {\n    const lowerHeaderName = name.toLowerCase();\n    if(this.readyState < this.HEADERS_RECEIVED || !(lowerHeaderName in this._response.headers)){\n      // IE <= 9 throws Error when readyState is UNSENT\n      /* istanbul ignore next */\n      if(isIE(\"<=\", 9)){\n        if(this.readyState < this.OPENED){\n          throw new Error();\n        }\n        return \"\";\n      }\n      return null;\n    }\n    return this._response.headers[lowerHeaderName];\n  }\n  \n  public getAllResponseHeaders(): string {\n    if(this.readyState < this.HEADERS_RECEIVED){\n      // According to MDN, getAllResponseHeaders returns null if headers are not yet received.\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders\n      // But lib.dom.d.ts asserts it always returns string.\n      // Don't know which is correct.\n      \n      // IE <= 9 throws Error when readyState is UNSENT\n      /* istanbul ignore next */\n      if(isIE(\"<=\", 9) && this.readyState < this.OPENED){\n        throw new Error();\n      }\n      return \"\";\n    }\n    return toHeaderString(this._response.headers);\n  }\n  \n  public abort() {\n    // According to https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request ,\n    // it should throw an Error on abort() called when using synchronous request.\n    // However, it actually does not in some major browser.\n    /*\n    if(this._request.async === false){\n      throw new Error(\"Invalid access error\");\n    }\n   */\n    \n    this._isAborted = true;\n    this.status = 0;\n    this.readyState = this.UNSENT;\n    this._readyState = this.UNSENT;\n    \n    if(this._transitioning){\n      this._xhr.abort();\n    }\n    else{\n      this.dispatchEvent(makeProgressEvent(\"abort\", 0));\n    }\n    \n    this._transitioning = false;\n  }\n  \n  private static _createRequest(xhr: XMLHttpRequest): XhrRequest {\n    return {\n      ajaxType: \"xhr\" as const,\n      headers: {},\n      method: \"GET\",\n      url: \"\",\n      async: true,\n      timeout: 0,\n      upload: xhr.upload,\n    };\n  }\n  \n  private static _createResponse(){\n    return {\n      ajaxType: \"xhr\" as const,\n      status: 0,\n      statusText: \"\",\n      finalUrl: \"\",\n      responseType: \"\" as const,\n      headers: {},\n    };\n  }\n  \n  private _setupVirtualRequestForSending(body?: Document | BodyInit | null){\n    this._request.responseType = this.responseType;\n    this._request.timeout = this.timeout;\n    this._request.withCredentials = this.withCredentials;\n    this._request.body = body;\n    this._xhr.onabort = typeof(this.onabort) === \"function\" ? this.onabort.bind(this) : null;\n    this._xhr.onerror = typeof(this.onerror) === \"function\" ? this.onerror.bind(this) : null;\n    this._xhr.ontimeout = typeof(this.ontimeout) === \"function\" ? this.ontimeout.bind(this) : null;\n    this._xhr.onprogress = typeof(this.onprogress) === \"function\" ? this.onprogress.bind(this) : null;\n  }\n  \n  private _syncEventListenersToXHR(){\n    const addEventListeners = <K extends keyof XMLHttpRequestEventMap>(type: K) => {\n      const localListeners = this._listeners[type];\n      if(!localListeners || localListeners.length < 1){\n        return;\n      }\n    \n      for(let i=0;i<localListeners.length;i++){\n        this._xhr.addEventListener(type, localListeners[i].bind(this));\n      }\n    };\n  \n    addEventListeners(\"abort\");\n    addEventListeners(\"error\");\n    addEventListeners(\"timeout\");\n    addEventListeners(\"progress\");\n  }\n  \n  private _createRequestCallback(onCalled: () => unknown) : RequestCallback<\"xhr\"> {\n    type RequestCallbackOnlyWithDefaultFunc = {\n      (dummyResponse: XhrResponse): unknown;\n      moveToHeaderReceived?: (dummyResponse: XhrResponse) => void;\n      moveToLoading?: (dummyResponse: XhrResponse) => void;\n    };\n    \n    const cb: RequestCallbackOnlyWithDefaultFunc = (response: XhrResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n      \n      this.dispatchEvent(makeProgressEvent(\"loadstart\", 0));\n  \n      this._response = {\n        ...this._response,\n        ...response,\n      };\n  \n      this._runUntil(this.DONE);\n  \n      onCalled();\n    };\n    \n    const moveToHeaderReceived = (response: XhrResponse) => {\n      if(this.readyState >= this.HEADERS_RECEIVED){\n        return;\n      }\n      this._response = {\n        ...this._response,\n        ...response,\n      };\n      this._runUntil(this.HEADERS_RECEIVED);\n    };\n    \n    const moveToLoading = (response: XhrResponse) => {\n      if(this.readyState >= this.LOADING){\n        return;\n      }\n      this._response = {\n        ...this._response,\n        ...response,\n      };\n      this._runUntil(this.LOADING);\n    };\n    \n    cb.moveToHeaderReceived = moveToHeaderReceived;\n    cb.moveToLoading = moveToLoading;\n    \n    return cb as RequestCallback<\"xhr\">;\n  }\n  \n  private _createResponseCallback(onCalled: () => unknown) : ResponseCallback<\"xhr\"> {\n    return (response: XhrResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n      \n      this._response = {\n        ...this._response,\n        ...response,\n      };\n      \n      onCalled();\n    };\n  }\n  \n  private _loadHeaderFromXHRToVirtualResponse(){\n    this._response.status = this._xhr.status;\n    if(!this._isAborted){\n      this._response.statusText = this._xhr.statusText;\n    }\n    else{\n      return;\n    }\n    \n    const responseHeaders = this._xhr.getAllResponseHeaders();\n    const headerMap = toHeaderMap(responseHeaders);\n  \n    const keys = Object.keys(headerMap);\n    for(let i=0;i<keys.length;i++){\n      const key = keys[i];\n      const value = headerMap[key];\n      if(!this._response.headers[key]){\n        this._response.headers[key] = value;\n      }\n    }\n  }\n  \n  private _loadBodyFromXHRToVirtualResponse(){\n    if(!this._xhr.responseType){\n      this._response.responseText = this._xhr.responseText;\n      this._response.responseXML = this._xhr.responseXML;\n      this._response.response = this._xhr.responseText;\n    }\n    else if(this._xhr.responseType === \"text\"){\n      this._response.responseText = this._xhr.responseText;\n      this._response.response = this._xhr.responseText;\n    }\n    else if(this._xhr.responseType === \"document\"){\n      this._response.responseXML = this._xhr.responseXML;\n      this._response.response = this._xhr.responseXML;\n    }\n    else{\n      this._response.response = this._xhr.response;\n    }\n    \n    if(\"responseURL\" in this._xhr){\n      this._response.responseURL = this._xhr.responseURL;\n    }\n  }\n  \n  private _syncHeaderFromVirtualResponse(){\n    this.status = this._response.status;\n    this.statusText = this._response.statusText;\n    // Response headers will be requested via getResponseHeader/getAllResponseHeaders\n    // which get header values directly from this._response.\n  }\n  \n  private _syncBodyFromVirtualResponse(){\n    if(\"responseText\" in this._response){\n      this._responseText = this._response.responseText || \"\";\n    }\n    if(\"responseXML\" in this._response){\n      this._responseXML = this._response.responseXML || null;\n    }\n    if(\"body\" in this._response){\n      this.response = this._response.body || null;\n    }\n    if(\"response\" in this._response){\n      this.response = this._response.response;\n    }\n    if(\"responseURL\" in this._response){\n      this.responseURL = this._response.responseURL || \"\";\n    }\n  }\n  \n  private _onError(){\n    this._hasError = true;\n    this._readyState = this.UNSENT;\n    this.readyState = this.UNSENT;\n    this.status = 0;\n  }\n  \n  private _triggerStateAction(){\n    const readyStateChangeEvent = createEvent(\"readystatechange\");\n    \n    if(this._readyState === this.OPENED){\n      this.dispatchEvent(readyStateChangeEvent);\n    }\n    else if(this._readyState === this.HEADERS_RECEIVED){\n      this._syncHeaderFromVirtualResponse();\n      this.dispatchEvent(readyStateChangeEvent);\n    }\n    else if(this._readyState === this.LOADING){\n      this._syncHeaderFromVirtualResponse();\n      this.dispatchEvent(readyStateChangeEvent);\n    }\n    else if(this._readyState === this.DONE){\n      this._syncHeaderFromVirtualResponse();\n      this._syncBodyFromVirtualResponse();\n      \n      let isReturnResponseCalled = false;\n      \n      const returnResponse = () => {\n        isReturnResponseCalled = true;\n        \n        // Re-sync for a case that this._request/this._response is modified in callback\n        this._syncHeaderFromVirtualResponse();\n        this._syncBodyFromVirtualResponse();\n  \n        this.dispatchEvent(readyStateChangeEvent);\n  \n        const emitLoadEvent = () => {\n          if(!this._hasError){\n            this.dispatchEvent(makeProgressEvent(\"load\", 0));\n          }\n          this.dispatchEvent(makeProgressEvent(\"loadend\", 0));\n        };\n  \n        if(this._request.async === false){\n          emitLoadEvent();\n        }\n        else{\n          window.setTimeout(emitLoadEvent, 0);\n        }\n      };\n  \n      const listeners = Proxy.getResponseListeners();\n      let listenerPointer = 0;\n  \n      const executeNextListener = (): unknown => {\n        try{\n          if(listenerPointer >= listeners.length){\n            return returnResponse();\n          }\n      \n          const l = listeners[listenerPointer];\n      \n          // l: (request, response, callback) => unknown\n          if(l.length >= 3){\n            const userCallback = this._createResponseCallback(() => {\n              listenerPointer++;\n              executeNextListener();\n            });\n        \n            l.call(this, this._request, this._response, userCallback);\n            return;\n          }\n      \n          // l: (request, response) => unknown\n          l.call(this, this._request, this._response);\n      \n          listenerPointer++;\n          executeNextListener();\n        }\n        catch(e){\n          console.warn(\"XMLHttpRequest: Exception in response handler\", e);\n      \n          if(!isReturnResponseCalled){\n            listenerPointer++;\n            executeNextListener();\n          }\n        }\n      };\n  \n      executeNextListener();\n    }\n  }\n  \n  private _runUntil(state: number){\n    while(this._readyState < state && this._readyState < this.DONE){\n      this._readyState++;\n      this.readyState = this._readyState;\n    \n      this._triggerStateAction();\n    }\n  }\n}\n","export class ResponseProxy {\n  private _response: Response;\n  private _body?: BodyInit | null;\n  private _init?: ResponseInit;\n  \n  public headers: Headers;\n  public ok: boolean;\n  public redirected: boolean;\n  public status: number;\n  public statusText: string;\n  public trailer: Promise<Headers>;\n  public type: ResponseType;\n  public url: string;\n  \n  public body: ReadableStream<Uint8Array> | null;\n  public bodyUsed: boolean;\n  \n  public constructor(body?: BodyInit | null, init?: ResponseInit) {\n    this._response = new Response(body, init);\n    this._body = body;\n    this._init = init;\n  \n    this.headers = new Headers(init ? init.headers : undefined);\n    this.ok = false;\n    this.redirected = false;\n    this.status = init && init.status ? init.status : 0;\n    this.statusText = init && init.statusText ? init.statusText : \"\";\n    this.trailer = this._response.trailer;\n    this.type = \"basic\";\n    this.url = \"\";\n    \n    this.body = this._response.body;\n    this.bodyUsed = this._response.bodyUsed;\n  }\n  \n  public static error(){\n    return Response.error();\n  }\n  \n  public static redirect(url: string, status?: number){\n    return Response.redirect(url, status);\n  }\n  \n  public clone(){\n    return new ResponseProxy(this._body, this._init);\n  }\n  \n  public arrayBuffer(){\n    return this._response.arrayBuffer();\n  }\n  \n  public blob(){\n    return this._response.blob();\n  }\n  \n  public formData(){\n    return this._response.formData();\n  }\n  \n  public json(){\n    return this._response.json();\n  }\n  \n  public text(){\n    return this._response.text();\n  }\n}\n","import {Proxy} from \"../Proxy\";\nimport {FetchRequest, FetchResponse, RequestCallback, ResponseCallback, TResponse} from \"../index.type\";\nimport {ResponseProxy} from \"./Response\";\n\nclass FetchProxy {\n  private _request: FetchRequest;\n  private _response: FetchResponse;\n  private _input?: RequestInfo;\n  private _init?: RequestInit;\n  \n  public constructor(input: RequestInfo, init?: RequestInit) {\n    this._input = input;\n    this._init = init;\n  \n    this.dispatch = this.dispatch.bind(this);\n    this._onResponse = this._onResponse.bind(this);\n    this._createRequestCallback = this._createRequestCallback.bind(this);\n    this._createResponseCallback = this._createResponseCallback.bind(this);\n    \n    this._request = FetchProxy._createRequest(input, init);\n    this._response = FetchProxy._createResponse();\n  }\n  \n  public dispatch(): Promise<Response> {\n    return new Promise((resolve, reject) => {\n      const originalResponse = this._response;\n      let isDispatchFetchCalled = false;\n      \n      const dispatchFetch = () => {\n        isDispatchFetchCalled = true;\n        \n        if(originalResponse !== this._response){\n          this._onResponse().then((response) => {\n            resolve(response);\n          });\n          return;\n        }\n        \n        Proxy.OriginalFetch(this._request.url, this._request).then(response => {\n          const headers: Record<string, string> = {};\n          for(const key of response.headers.keys()){\n            const value = response.headers.get(key)\n            if(value){\n              headers[key] = value;\n            }\n          }\n          \n          this._response = {\n            ajaxType: \"fetch\",\n            status: response.status,\n            statusText: response.statusText,\n            headers,\n            ok: response.ok,\n            redirected: response.redirected,\n            type: response.type,\n            url: response.url,\n            body: response.body,\n          };\n          \n          this._onResponse().then(r => {\n            resolve(r);\n          });\n        });\n      };\n  \n      const requestListeners = Proxy.getRequestListeners();\n      let listenerPointer = 0;\n  \n      const executeNextListener = (): unknown => {\n        try{\n          if(listenerPointer >= requestListeners.length){\n            return dispatchFetch();\n          }\n      \n          const l = requestListeners[listenerPointer];\n      \n          // l: (request, callback) => unknown\n          if(l.length >= 2){\n            const userCallback = this._createRequestCallback(() => {\n              listenerPointer++;\n              executeNextListener();\n            });\n        \n            l.call({}, this._request, userCallback as RequestCallback<\"xhr\"|\"fetch\">);\n            return;\n          }\n      \n          // l: (request) => unknown\n          l.call({}, this._request);\n      \n          listenerPointer++;\n          executeNextListener();\n        }\n        catch(e){\n          console.warn(\"XMLHttpRequest: Exception in request handler\", e);\n      \n          if(!isDispatchFetchCalled){\n            listenerPointer++;\n            executeNextListener();\n          }\n        }\n      };\n  \n      executeNextListener();\n    });\n  }\n  \n  private _onResponse(){\n    return new Promise<Response>((resolve => {\n      let isReturnResponseCalled = false;\n  \n      const returnResponse = () => {\n        isReturnResponseCalled = true;\n        const res = new ResponseProxy(this._response.body, this._response);\n        res.url = this._response.url;\n        res.type = this._response.type;\n        res.redirected = this._response.redirected;\n        res.ok = this._response.ok;\n        resolve(res);\n      };\n  \n      const responseListeners = Proxy.getResponseListeners();\n      let listenerPointer = 0;\n  \n      const executeNextListener = (): unknown => {\n        try{\n          if(listenerPointer >= responseListeners.length){\n            return returnResponse();\n          }\n      \n          const l = responseListeners[listenerPointer];\n      \n          // l: (request, response, callback) => unknown\n          if(l.length >= 3){\n            const userCallback = this._createResponseCallback(() => {\n              listenerPointer++;\n              executeNextListener();\n            });\n        \n            l.call({}, this._request, this._response, userCallback);\n            return;\n          }\n      \n          // l: (request, response) => unknown\n          l.call({}, this._request, this._response);\n      \n          listenerPointer++;\n          executeNextListener();\n        }\n        catch(e){\n          console.warn(\"XMLHttpRequest: Exception in request handler\", e);\n      \n          if(!isReturnResponseCalled){\n            listenerPointer++;\n            executeNextListener();\n          }\n        }\n      };\n  \n      executeNextListener();\n    }));\n  }\n  \n  private static _createRequest(input: RequestInfo, init?: RequestInit): FetchRequest {\n    if(typeof input === \"string\"){\n      const req = {\n        ...(init||{}),\n        ajaxType: \"fetch\",\n        headers: {},\n        url: input,\n      } as FetchRequest;\n      \n      if(init && init.headers){\n        const headers = init.headers instanceof Headers ? init.headers : new Headers(init.headers);\n  \n        /**\n         * Webpack's es5 output for `for-of` loop over iterable does not work as expected as of 2020/08/08.\n         * \n         * for(const pair of headers.entries()){\n         *   ...\n         * }\n         * \n         * will be converted to\n         * \n         * for (var _i = 0, _a = headers.entries(); _i < _a.length; _i++) {\n         *   ...\n         * }\n         * \n         * Since headers.entries() returns not an array but iterable, `_a.length` is undefined.\n         * So the loop never run.\n         * As a work around, I convert iterable to an array as below.\n         */\n        const entries = Array.from(headers.entries());\n        for(let i=0;i<entries.length;i++){\n          const pair = entries[i];\n          const key = pair[0];\n          const value = pair[1];\n          if(value){\n            req.headers[key] = value;\n          }\n        }\n      }\n      \n      return req;\n    }\n    else{\n      const headers = input.headers || (init && init.headers ? init.headers : null);\n      \n      const req = {\n        ...(init||{}),\n        ajaxType: \"fetch\",\n        method: input.method,\n        url: input.url,\n        timeout: 0,\n        headers: {},\n        // input.body may be `undefined` since major browsers does not support it as of 2020/08/06.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#bcd:api.Request.Request\n        body: input.body,\n        cache: input.cache,\n        credentials: input.credentials,\n        integrity: input.integrity,\n        keepalive: input.keepalive,\n        mode: input.mode,\n        redirect: input.redirect,\n        referrer: input.referrer,\n        referrerPolicy: input.referrerPolicy,\n        signal: input.signal,\n      } as FetchRequest;\n  \n      if(headers){\n        const entries = Array.from(headers.entries());\n        for(let i=0;i<entries.length;i++){\n          const pair = entries[i];\n          const key = pair[0];\n          const value = pair[1];\n          if(value){\n            req.headers[key] = value;\n          }\n        }\n      }\n      \n      return req;\n    }\n  }\n  \n  private static _createResponse(): FetchResponse {\n    return {\n      ajaxType: \"fetch\",\n      status: 0,\n      statusText: \"\",\n      headers: {},\n      ok: true,\n      redirected: false,\n      type: \"basic\",\n      url: \"\",\n      body: null,\n    };\n  }\n  \n  private _createRequestCallback(onCalled: () => unknown): RequestCallback<\"fetch\"> {\n    type RequestCallbackOnlyWithDefaultFunc = {\n      (dummyResponse: FetchResponse): unknown;\n      moveToHeaderReceived?: (dummyResponse: TResponse<\"fetch\">) => void;\n      moveToLoading?: (dummyResponse: TResponse<\"fetch\">) => void;\n    };\n  \n    const cb: RequestCallbackOnlyWithDefaultFunc = (response: FetchResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n  \n      this._response = response;\n      onCalled();\n    };\n    \n    cb.moveToHeaderReceived = () => { return; };\n    cb.moveToLoading = () => { return; };\n    \n    return cb as RequestCallback<\"fetch\">;\n  }\n  \n  private _createResponseCallback(onCalled: () => unknown) : ResponseCallback<\"fetch\"> {\n    return (response: FetchResponse) => {\n      if(!response || typeof response !== \"object\"){\n        onCalled();\n        return;\n      }\n      \n      this._response = response;\n      \n      onCalled();\n    };\n  }\n  \n}\n\nexport function fetchProxy(input: RequestInfo, init?: RequestInit): Promise<Response> {\n  const fetch = new FetchProxy(input, init);\n  return fetch.dispatch();\n}","import {Proxy} from \"./Proxy\";\nimport {WindowEx} from \"./index.type\";\nimport {XHRProxy} from \"./modules/XMLHttpRequest\";\nimport {fetchProxy} from \"./modules/fetch\";\n\ndeclare let window: WindowEx;\n\nProxy.setXMLHttpRequest(XHRProxy);\nProxy.setFetch(fetchProxy);\nProxy.enable();\n\nexport default Proxy;\n"],"sourceRoot":""}